{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"8551840388622460043","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"path_indices","type":{"kind":"array","length":32,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient_binding","type":{"kind":"field"},"visibility":"public"},{"name":"raffle_id","type":{"kind":"field"},"visibility":"public"},{"name":"winner_index","type":{"kind":"field"},"visibility":"public"},{"name":"tree_depth","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\n\n// Maximum Merkle tree depth (supports up to 2^32 = 4,294,967,296 participants)\nglobal MAX_DEPTH: u32 = 32;\n\n// Compute Poseidon2 hash of two Field elements\nfn hash2(a: Field, b: Field) -> Field {\n    Poseidon2::hash([a, b], 2)\n}\n\n// Compute Poseidon2 hash of a single Field element\nfn hash1(a: Field) -> Field {\n    Poseidon2::hash([a], 1)\n}\n\nfn main(\n    // PRIVATE INPUTS\n    secret: Field,\n    nullifier: Field,\n    siblings: [Field; MAX_DEPTH],\n    path_indices: [Field; MAX_DEPTH],  // 0 or 1 for each level\n    recipient: Field,\n    \n    // PUBLIC INPUTS\n    root: pub Field,\n    nullifier_hash: pub Field,\n    recipient_binding: pub Field,\n    raffle_id: pub Field,\n    winner_index: pub Field,\n    tree_depth: pub Field\n) {\n    // Convert tree_depth to u32 for comparisons\n    let depth = tree_depth as u32;\n    assert(depth <= MAX_DEPTH);\n    assert(depth > 0);\n    \n    // commitment = Poseidon2(secret, nullifier)\n    let commitment = hash2(secret, nullifier);\n    \n    let computed_nullifier_hash = hash1(nullifier);\n    assert(computed_nullifier_hash == nullifier_hash);\n    \n    let computed_recipient_binding = hash2(nullifier_hash, recipient);\n    assert(computed_recipient_binding == recipient_binding);\n    \n    let mut reconstructed_index: Field = 0;\n    let mut power_of_two: Field = 1;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let bit = path_indices[i];\n            // Ensure bit is 0 or 1\n            assert(bit * (bit - 1) == 0);\n            reconstructed_index = reconstructed_index + bit * power_of_two;\n            power_of_two = power_of_two * 2;\n        }\n    }\n    assert(reconstructed_index == winner_index);\n    \n    let mut current_hash = commitment;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let sibling = siblings[i];\n            let is_right = path_indices[i];\n            \n            let left = if is_right == 0 { current_hash } else { sibling };\n            let right = if is_right == 0 { sibling } else { current_hash };\n            \n            current_hash = hash2(left, right);\n        }\n    }\n    assert(current_hash == root);\n    \n    assert(raffle_id != 0);\n}\n\n#[test]\nfn test_hash2() {\n    let h = hash2(1, 2);\n    assert(h != 0);\n}\n\n#[test]\nfn test_hash1() {\n    let h = hash1(42);\n    assert(h != 0);\n}\n\n#[test]\nfn test_simple_merkle_proof() {\n    let secret: Field = 123;\n    let nullifier: Field = 456;\n    let commitment = hash2(secret, nullifier);\n    \n    let leaf1 = hash2(789, 101112);\n    \n    let computed_root = hash2(commitment, leaf1);\n    \n    let mut siblings: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n    siblings[0] = leaf1;\n    \n    let path_indices: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n  \n    let mut current = commitment;\n    let sibling = siblings[0];\n    let is_right = path_indices[0];\n    let left = if is_right == 0 { current } else { sibling };\n    let right = if is_right == 0 { sibling } else { current };\n    current = hash2(left, right);\n    \n    assert(current == computed_root);\n}\n","path":"/home/david/raffero-backend/circuits/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/david/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}
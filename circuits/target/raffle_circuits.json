{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"18171757696980969466","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"path_indices","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient_binding","type":{"kind":"field"},"visibility":"public"},{"name":"raffle_id","type":{"kind":"field"},"visibility":"public"},{"name":"winner_index","type":{"kind":"field"},"visibility":"public"},{"name":"tree_depth","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"tZjRbuM4DEX/Jc99EEmREudXFosibdNBgCAtMu0Ci2L+fSWZ12kfHMzaMy++t7F4LFGknOZj93R4eP9+fzw/v/zYffvrY/dwOZ5Ox+/3p5fH/dvx5dw+/fh5t8Of92+Xw6F9tPt0v0W97i+H89vu2/n9dLrb/bM/vY9BP17356Fv+0u7m+52h/NT0wZ8Pp4O3f28u0an5VDKWiKacskzQP8Hoc4ETbqGoOQzgesaghXkgMwXV5GXCUYAmNhSvC7Hi3LEZ/oUX77E23I8c0UOWBIvEcqNHJBhCkRV18yhkGEORdISwW/MoRTBHIovroJubKVnDYJrXQOgxHMekumaVXia69F5cRW35lBlJlRd7Am6UZCFaxCK0iJga0XSrXKwip5gc1lE3KpJuWZSeHk769Z6uJUHr3MedFUefq0tmDb3RS/cjWV9cxa/oa6tzoTkK05qTteiIuIlAtvGo5rLxs7guvmwZt98Wt+cxa/VpWyvS+GN/SnbC1v+aGEzsc5lWXhNYef5wOacZQ1BE75IsVJeR0hXgm4lcFpF0OsqvKwhiOc5k2ldJotvnIPx3FuWV9WDFZq7M9kaghOak53X1INQQSaF6po8iMxfZER0kZDrxuM6+8bjWtPmg1K3H5S69aDU7Qel/tGDUqQil5JXlbVowjJE6Svh7/bX/vF4+fJf8i612d7taFx5XGVc87jquNq4lnGt4+pTVAS36PZU4klkkjxJI7TNJZukTFIn6ZQ2hlMohXZQu88S2lFtf7mzWs9xh7VEcaPllgxuuNzjfFJJoRTK0ziR0Byqcd9CS2jwxKdxOYVSaOf1FEloDg1eDl4OXg5eDp4GT4OnndfWqcHT4KmGWmgJDZ7Gei3Wa7Fei/VarNdivabTcyx4FjyroT5pSaHBKxwqoTlUJ26x0NiPUqfnlODV4FUKjfzVWG8NXo381chfjfzVOnFr5M8jf07Tczx4HjyP/Hnkz2O9HjyP/Hnkj1KCiR1ppwGMwOTpYZSC2o4JmAJTYWLlRCATwTCMwMT2ECmMwZR4KIFMIHOCIRiGAZkzjMIYTOwVcYWJ7NJon/5QAVlAFoHJMMjGaCLtppNLNxXGw/RG0twNwTCMwGQYRZTBgJxBziAryAqygjy6aozJMCAryAqygtx7a4QbyAbyaK8+xkA2kA1kA9lA7k02hYNcQB591scUkAvIBeQCcgG5d9sUDnIBeTRcH1NBriBXkCvIFeTedlM4yBXkijw7yA6yg+wgO8i9/0a4g+wgO/LsQeaUYAiGYQQmaoOTwhhMwZgKAzKBTCATyBRVxwQygUyGMSATyAQyg8wgc1QdM8gMcu9B7W+t3oM6Bpfx5aC/zS/H/cPpED9bP7+fHz/9iv327yvu4Hfu18vL4+Hp/XLo7/Jxr73d/wM=","file_map":{"50":{"source":"// =============================================================================\n// Private Raffle ZK Circuit - Noir v1.0.0-beta9\n// =============================================================================\n// Uses Poseidon2 hash function for cryptographic compatibility with Solidity contract\n// =============================================================================\n\nuse poseidon::poseidon2::Poseidon2;\n\n// Maximum Merkle tree depth (supports up to 2^10 = 1,024 participants)\nglobal MAX_DEPTH: u32 = 10;\n\n// Compute Poseidon2 hash of two Field elements\nfn hash2(a: Field, b: Field) -> Field {\n    Poseidon2::hash([a, b], 2)\n}\n\n// Compute Poseidon2 hash of a single Field element  \nfn hash1(a: Field) -> Field {\n    Poseidon2::hash([a], 1)\n}\n\n// =============================================================================\n// MAIN CIRCUIT\n// =============================================================================\n\nfn main(\n    // PRIVATE INPUTS (known only to the prover/winner)\n    secret: Field,\n    nullifier: Field,\n    siblings: [Field; MAX_DEPTH],\n    path_indices: [Field; MAX_DEPTH],  // 0 or 1 for each level\n    recipient: Field,\n    \n    // PUBLIC INPUTS (visible to the verifier/contract)\n    root: pub Field,\n    nullifier_hash: pub Field,\n    recipient_binding: pub Field,\n    raffle_id: pub Field,\n    winner_index: pub Field,\n    tree_depth: pub Field\n) {\n    // Convert tree_depth to u32 for comparisons\n    let depth = tree_depth as u32;\n    assert(depth <= MAX_DEPTH);\n    assert(depth > 0);\n    \n    // STEP 1: Compute the commitment from secret and nullifier\n    // commitment = Poseidon2(secret, nullifier)\n    let commitment = hash2(secret, nullifier);\n    \n    // STEP 2: Verify nullifier hash is computed correctly\n    // nullifier_hash = Poseidon2(nullifier)\n    let computed_nullifier_hash = hash1(nullifier);\n    assert(computed_nullifier_hash == nullifier_hash);\n    \n    // STEP 3: Verify recipient binding is computed correctly\n    // recipient_binding = Poseidon2(nullifier_hash, recipient)\n    let computed_recipient_binding = hash2(nullifier_hash, recipient);\n    assert(computed_recipient_binding == recipient_binding);\n    \n    // STEP 4: Verify path_indices match winner_index\n    // Reconstruct index from path bits\n    let mut reconstructed_index: Field = 0;\n    let mut power_of_two: Field = 1;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let bit = path_indices[i];\n            // Ensure bit is 0 or 1\n            assert(bit * (bit - 1) == 0);\n            reconstructed_index = reconstructed_index + bit * power_of_two;\n            power_of_two = power_of_two * 2;\n        }\n    }\n    assert(reconstructed_index == winner_index);\n    \n    // STEP 5: Verify Merkle proof\n    // Uses same Poseidon2 hash as the contract\n    let mut current_hash = commitment;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let sibling = siblings[i];\n            let is_right = path_indices[i];\n            \n            // If is_right == 0, current is left child; if is_right == 1, current is right child\n            // This matches the contract's Merkle tree construction\n            let left = if is_right == 0 { current_hash } else { sibling };\n            let right = if is_right == 0 { sibling } else { current_hash };\n            \n            current_hash = hash2(left, right);\n        }\n    }\n    assert(current_hash == root);\n    \n    // STEP 6: Verify raffle_id is valid (prevents cross-raffle proof reuse)\n    assert(raffle_id != 0);\n}\n\n// =============================================================================\n// TESTS\n// =============================================================================\n\n#[test]\nfn test_hash2() {\n    let h = hash2(1, 2);\n    assert(h != 0);\n}\n\n#[test]\nfn test_hash1() {\n    let h = hash1(42);\n    assert(h != 0);\n}\n\n#[test]\nfn test_simple_merkle_proof() {\n    // Create a simple depth-1 tree\n    let secret: Field = 123;\n    let nullifier: Field = 456;\n    let commitment = hash2(secret, nullifier);\n    \n    // Second leaf (dummy)\n    let leaf1 = hash2(789, 101112);\n    \n    // Root = hash(commitment, leaf1) since commitment is at index 0\n    let computed_root = hash2(commitment, leaf1);\n    \n    // Merkle proof for leaf at index 0\n    let mut siblings: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n    siblings[0] = leaf1;\n    \n    // Path indices for index 0: all zeros\n    let path_indices: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n    \n    // Verify merkle proof inline\n    let mut current = commitment;\n    let sibling = siblings[0];\n    let is_right = path_indices[0];\n    let left = if is_right == 0 { current } else { sibling };\n    let right = if is_right == 0 { sibling } else { current };\n    current = hash2(left, right);\n    \n    assert(current == computed_root);\n}\n","path":"/home/david/raffero-backend/circuits/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/david/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}